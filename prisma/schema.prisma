generator client {
  provider = "prisma-client"
  output   = "./generated"
}

datasource db {
  provider = "postgresql"
}

model User {
  id         String    @id @default(cuid())
  created_at DateTime  @default(now())
  updated_at DateTime  @default(now())
  deleted_at DateTime?

  // Account status & approval
  status      UserStatus @default(DEACTIVATED)
  approved_at DateTime?
  approved_by String? // admin user id who approved

  // Auth & identity
  email    String? @unique
  username String? @unique
  password String? @db.VarChar(255)

  // Profile
  name       String? @db.VarChar(255)
  first_name String? @db.VarChar(255)
  last_name  String? @db.VarChar(255)
  avatar     String?

  // Timezone (from settings screen)
  timezone String? @default("UTC")

  role              Role      @default(AUTHORIZED_VIEWER)
  email_verified_at DateTime?

  // Merged from Ucode — password reset / email verification tokens
  password_reset_token          String?
  password_reset_expires_at     DateTime?
  password_reset_otp            String? // hashed OTP
  password_reset_otp_expires_at DateTime? // OTP expiry (short ~10min)
  password_reset_verified_at    DateTime?

  // Access expiration (admin-controlled per user)
  access_expires_at DateTime?
  access_revoked_at DateTime?
  access_revoked_by String? // admin user id who revoked

  // soft delete flag
  isDeleted Boolean @default(false)

  // Relations
  receiver_notifications Notification[] @relation("receiver")
  sender_notifications   Notification[] @relation("sender")

  // Properties this user has access to
  property_access PropertyAccess[]

  // Audit: actions performed by this user
  audit_logs AuditLog[]

  @@map("users")
}

// Junction table: which users have access to which properties
model PropertyAccess {
  id         String   @id @default(cuid())
  created_at DateTime @default(now())
  updated_at DateTime @default(now())

  user_id     String
  user        User     @relation(fields: [user_id], references: [id])
  property_id String
  property    Property @relation(fields: [property_id], references: [id])

  // Role override at property level (optional, falls back to user.role)
  role String?

  // Time-limited access for insurers, consultants, etc.
  expires_at DateTime?
  revoked_at DateTime?
  granted_by String? // admin user id

  @@unique([user_id, property_id])
  @@map("property_access")
}

model Property {
  id         String   @id @default(cuid())
  created_at DateTime @default(now())
  updated_at DateTime @default(now())

  status Int? @default(1) @db.SmallInt

  name       String? @db.VarChar(255)
  identifier String? @unique @db.VarChar(255) // short code / slug
  address    String?
  city       String?
  state      String?
  zip_code   String?
  country    String?

  // Dashboard display
  // Values: "complete" | "in_progress" | "missing"
  dashboard_status String?   @default("in_progress")
  last_updated_at  DateTime?
  next_action_at   DateTime?
  notes            String?

  // Template this was created from
  template_id String?
  template    PropertyTemplate? @relation(fields: [template_id], references: [id])

  // Relations
  user_access PropertyAccess[]
  documents   Document[]
  audit_logs  AuditLog[]

  @@map("properties")
}

model PropertyTemplate {
  id         String   @id @default(cuid())
  created_at DateTime @default(now())
  updated_at DateTime @default(now())

  name        String? @db.VarChar(255)
  description String?

  // JSON config: required/optional document categories, status fields, etc.
  config Json?

  properties Property[]

  @@map("property_templates")
}

// Documents, photos, videos — append-only, versioned
model Document {
  id         String   @id @default(cuid())
  created_at DateTime @default(now())
  updated_at DateTime @default(now())

  property_id String
  property    Property @relation(fields: [property_id], references: [id])

  // File metadata
  name      String? @db.VarChar(255)
  // Values: "document" | "photo" | "video" | "embed"
  type      String? @db.VarChar(50)
  category  String? @db.VarChar(255) // folder/category label
  url       String? // cloud storage URL or external embed URL
  mime_type String? @db.VarChar(100)
  file_size Int? // bytes

  // Versioning (append-only)
  version     Int?    @default(1)
  is_current  Boolean @default(true)
  previous_id String? // points to prior version

  // For embedded external content (3D tours, maps, etc.)
  embed_url  String?
  embed_type String? @db.VarChar(50) // "3d_tour" | "map" | "video" | "external_doc"

  // Uploader
  uploaded_by String? // user id

  // Status indicator for required doc tracking
  // Values: "complete" | "in_progress" | "missing"
  doc_status String? @default("complete")

  audit_logs AuditLog[]

  @@map("documents")
}

model AuditLog {
  id         String   @id @default(cuid())
  created_at DateTime @default(now())

  // Who did it
  user_id String?
  user    User?   @relation(fields: [user_id], references: [id])

  // What was affected
  property_id String?
  property    Property? @relation(fields: [property_id], references: [id])
  document_id String?
  document    Document? @relation(fields: [document_id], references: [id])

  // What happened
  // e.g. "file_upload" | "status_update" | "user_access_granted" | "user_access_revoked" | "login" | "password_reset"
  action      String?
  entity_type String? // "user" | "property" | "document"
  entity_id   String?

  // Snapshot of changes (JSON diff)
  metadata Json?

  @@map("audit_logs")
}

model NotificationEvent {
  id         String   @id @default(cuid())
  created_at DateTime @default(now())
  updated_at DateTime @default(now())

  status Int?    @default(1) @db.SmallInt
  // e.g. "new_access_request" | "access_approved" | "access_denied" | "dashboard_update" | "new_upload" | "access_expiring_soon"
  type   String?
  text   String?

  notifications Notification[]

  @@map("notification_events")
}

model Notification {
  id         String   @id @default(cuid())
  created_at DateTime @default(now())
  updated_at DateTime @default(now())

  read_at DateTime?
  status  Int?      @default(1) @db.SmallInt

  sender_id String?
  sender    User?   @relation("sender", fields: [sender_id], references: [id])

  receiver_id String?
  receiver    User?   @relation("receiver", fields: [receiver_id], references: [id])

  notification_event_id String?
  notification_event    NotificationEvent? @relation(fields: [notification_event_id], references: [id])

  entity_id String?

  @@map("notifications")
}

enum Role {
  ADMIN
  PROPERTY_MANAGER
  AUTHORIZED_VIEWER
  OPERATIONAL
}

enum UserStatus {
  ACTIVE
  DEACTIVATED
  DELETED
}
